Данный проект посвящён асинхронности в Python, но в рамках одного потока и процесса. То есть многопоточность здесь
не используется.

Задачи бывают двух видов: первая категория завязана на работе с CPU или GPU (вычисления, рендеринг видео, аудио и т.д.),
вторая категория завязана на вводе данных и на выводе (I/O задачи: получили данные, обработали и возвращаем результат).
Асинхронное программирование применяется к решению задач второй категории.

Web-app

Содержит простое небольшое веб-приложение на низком уровне.
В этом приложении показан пример использования сокетов и роутинга (маршрутизации).
По такому принципу фреймворки типа Flask и Django обрабатывают запросы от пользователей (браузера) и осуществляют
маршрутизацию. Подробнее можно почитать в личных записях в разделе, посвящённому асинхронности.

original.py

По сути дублирует проект web-app, однако упрощён. Файл необходим для постановки проблемы.
При такой реализации работы клиента с сервером существует одна проблема. Когда первый клиент подключается к серверу,
то мы попадаем во второй внутренний бесконечный цикл и начинаем ждать от него ответа и работать только с ним.
Проблема в том, что пока первый клиент не разорвёт соединение, то второй клиент не сможет подключиться.
Для решения этой проблемы нужен механизм, который мог бы передавать контроль управления какому-то участку кода в
зависимости от наступления какого-либо ожидаемого события. Например, пока первый клиент думает над запросом, нужно
принять подключение от ещё одного клиента и его обработать. Также нужен код менеджер, который бы управлял этим
процессом. Такой код менеджер называют циклом событий. Цикл событий при этом должен работать асинхронно.
