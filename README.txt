Данный проект посвящён асинхронности в Python, но в рамках одного потока и процесса. То есть многопоточность здесь
не используется.

Задачи бывают двух видов: первая категория завязана на работе с CPU или GPU (вычисления, рендеринг видео, аудио и т.д.),
вторая категория завязана на вводе данных и на выводе (I/O задачи: получили данные, обработали и возвращаем результат).
Асинхронное программирование применяется к решению задач второй категории.

Web-app

Содержит простое небольшое веб-приложение на низком уровне.
В этом приложении показан пример использования сокетов и роутинга (маршрутизации).
По такому принципу фреймворки типа Flask и Django обрабатывают запросы от пользователей (браузера) и осуществляют
маршрутизацию. Подробнее можно почитать в личных записях в разделе, посвящённому асинхронности.

original.py

По сути дублирует проект web-app, однако упрощён. Файл необходим для постановки проблемы.
При такой реализации работы клиента с сервером существует одна проблема. Когда первый клиент подключается к серверу,
то мы попадаем во второй внутренний бесконечный цикл и начинаем ждать от него ответа и работать только с ним.
Проблема в том, что пока первый клиент не разорвёт соединение, то второй клиент не сможет подключиться.
Для решения этой проблемы нужен механизм, который мог бы передавать контроль управления какому-то участку кода в
зависимости от наступления какого-либо ожидаемого события. Например, пока первый клиент думает над запросом, нужно
принять подключение от ещё одного клиента и его обработать. Также нужен код менеджер, который бы управлял этим
процессом. Такой код менеджер называют циклом событий. Цикл событий при этом должен работать асинхронно.

1_select.py

Для асинхронности нужно определить, какие сокеты готовы для чтения и для записи. Далее вызвать у них соответствующие
методы: .accept(), .recv(), .send(). Затем описать механизм переключения между этими функциями.
Чтобы узнать, какой сокет готов для чтения или для записи, необходимо использовать метод select().
Select() необходима для мониторинга изменения состояний файловых объектов, коими и являются сокеты. В Unix системах
всё являются файлами: устройства, процессы и т.д. (именно метод .bind() создаёт файл сокета). Select() работает с любым
файловым объектом, у которого есть метод .fileno(), возвращающий файловый дескриптор (номер файла в системе).
Если речь идёт о серверном сокете, то под ожидаемым событием подразумевается появление во входящем буфере нового
подключения, то есть клиента. У клиентского сокета событие – это появление во входящем буфере данных от пользователя.
Для метода отправки ответа клиенту событием будет очистка буфера отправки; то есть когда буфер пустой, то сокет готов
туда что-то записать.
Таким образом пока один сокет ждёт, мы передаём управление другому сокету, а когда сокет готов, то мы передаём
управление ему.

2_selectors.py

Асинхронность с использованием модуля selectors и колбэков.
Selectors - платформонезависимый модуль, который является слоем более абстрактной логики над функцией select()
и другими аналогичными функциями. Этот модуль выполняет тот же самый мониторинг над файловыми объектами, что и select().
Поэтому задача остаётся той же: его необходимо 'подкармливать' объектами, за которыми необходимо мониторить.

3_async_gens.py

Асинхронность на основе генераторов.
Предложил метод David Beazley, 2015 PyCon, "Concurrency from the Ground up Live". Статья переведена на русский.

4_coroutines.py

В этом файле представлены корутины (сопрограммы), которые реализуются с помощью генераторов.
Корутины – по сути генераторы, которые в процессе своей работы могут принимать извне какие-то данные. Реализуются с
помощью метода .send().
