Данный проект посвящён асинхронности в Python, но в рамках одного потока и процесса. То есть без использования
многопоточности.

Задачи бывают двух видов: первая категория завязана на работе с CPU или GPU (вычисления, рендеринг видео, аудио и т.д.),
вторая категория завязана на вводе данных и на выводе (I/O задачи: получение данных, обработка и возвращение
результата). Асинхронное программирование применяется к решению задач второй категории.

Web-app

Содержит простое небольшое веб-приложение на низком уровне.
В этом приложении показан пример использования сокетов и роутинга (маршрутизации).
По такому принципу фреймворки типа Flask и Django обрабатывают запросы от пользователя (браузера) и осуществляют
маршрутизацию.

original.py

Упрощённая версия web-app. Необходим для постановки проблемы.
При демонстрируемой реализации работы клиента с сервером существует проблема. Когда первый клиент подключается к
серверу, то мы попадаем во второй внутренний бесконечный цикл и начинаем работать только с ним. Проблема в том, что,
пока первый клиент не разорвёт соединение, второй клиент не сможет подключиться.
Для решения этой проблемы нужен механизм, который мог бы передавать контроль управления какому-то участку кода в
зависимости от наступления какого-либо ожидаемого события. Например, пока первый клиент думает над запросом, можно
принять ещё одно подключение и его обработать. Также нужен код менеджер, который бы управлял этим процессом. Такой код
менеджер называют циклом событий. Цикл событий при этом должен работать асинхронно.

1_select.py

Для реализации асинхронности нужно определить, какие сокеты готовы для чтения и для записи.
Далее вызвать у них соответствующие методы: .accept(), .recv() и .send().
Затем описать механизм переключения между этими функциями.
Чтобы узнать, какой сокет готов для чтения или для записи, необходимо использовать метод select(). select() необходима
для мониторинга изменения состояний файловых объектов, коими и являются сокеты. В Unix системах всё является файлами:
устройства, процессы и т. д. Метод .bind() создаёт файл сокета. select() работает с любым файловым объектом, у
которого есть метод .fileno(), возвращающий файловый дескриптор (номер файла в системе).
Для серверного сокета ожидаемым событием является появление во входящем буфере нового подключения, то есть клиента. Мы
отслеживаем момент, когда серверный сокет станет готов для чтения.
У клиентского сокета два события: появление во входящем буфере запроса от пользователя (готовность для чтения) и
очистка буфера отправки (готовность для записи). Если буфер отправки пустой, то мы готовы туда что-то записать.
Таким образом пока один сокет ждёт, мы передаём управление другому сокету, а когда сокет готов, то мы передаём
управление ему.

2_selectors.py

Асинхронность с использованием модуля selectors и колбэков.
Selectors - платформонезависимый модуль, который является слоем более абстрактной логики над функцией select() и
другими аналогичными функциями. Этот модуль выполняет тот же мониторинг над файловыми объектами, что и select().
Поэтому задача остаётся той же: его необходимо 'подкармливать' объектами, за которыми необходимо наблюдать.

3_async_gens.py

Асинхронность на основе генераторов.
Предложил метод David Beazley, 2015 PyCon, "Concurrency from the Ground up Live". Статья переведена на русский.

4_coroutines.py

В этом файле представлены корутины (сопрограммы), которые реализуются с помощью генераторов.
Корутины – по сути генераторы, которые в процессе своей работы могут принимать извне какие-то данные. Реализуются с
помощью метода .send().

5_delegators.py

Делегирующие генераторы и подгенераторы.
Делегирующий генератор - это тот генератор, который вызывает какой-либо другой.
Подгенератор - вызываемый генератор.
Такая конструкция возможна, когда нужно разбить один генератор на несколько.

6_asyncio_async_await.py

В предыдущих задачах мы объявляли список событий (задач), который определённым образом обрабатывали в событийном цикле.
Такими событиями были сокеты, которые изменяли своё состояние. Каждый сокет был ассоциирован с какой-то
функцией-обработчиком, и, когда он менял своё состояние, вызывалась эта функция. Такая ассоциация была реализована
с помощью именованных кортежей (2_selectors.py) и словарей (3_async_gens.py), которые прокручивались в событийном цикле.
В модуле asyncio в событийном цикле крутятся экземпляры класса Task, которые по сути являются контейнерами для корутин.
Класс Task - это подкласс Future. Можно сказать, что экземпляры класса Task - это и есть те действия, которые должны
выполняться асинхронно. Класс Future является своего рода заглушкой: так как любая функция является блокирующей, то,
чтобы при её вызове выполнение всего кода не застопорилось, она должна сразу что-то вернуть. Возвращает она именно
заглушку Future (в js аналогичная конструкция называется promise).
Помимо ассоциированной с ним корутины класс Task содержит атрибуты для доступа к результатам работы этой корутины,
атрибуты для доступа к исключению (если оно было возбуждено). Поскольку экземпляры Task это объекты, то их можно
помещать на выполнение в очередь, спрашивать, выполнилась ли связанная с этим экземпляром корутина, был ли получен
результат и т.д.
Работа asyncio аналогична примерам выше. Событийный цикл берёт первую в очереди задачу Task, у ассоциированной с этим
экземпляром корутины вызывается метод .step(), корутина выполняет свой код. Если корутина вызывает другую корутину,
то делегирующая корутина приостанавливает своё выполнение и контроль выполнения переходит в вызванную корутину, если
корутина вызывает блокирующую функцию, то она также останавливается, но контроль возвращается уже в событийный цикл.
Затем событийный цикл берёт следующую задачу и так далее. Если событийный цикл опять доходит до первой задачи, то она
продолжает своё выполнение с того момента, на котором остановилась в прошлый раз.

7_async.py

Программа скачивает картинки с сайта в синхронном и асинхронном стиле с замером времени.
